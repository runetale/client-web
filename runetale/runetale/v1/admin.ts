// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v3.20.3
// source: runetale/runetale/v1/admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import { Empty } from "../../../google/protobuf/empty";

export const protobufPackage = "protos";

export enum IPProto {
  ALL = 0,
  TCP = 6,
  UDP = 17,
  ICMPv4 = 1,
  ICMPv6 = 58,
  UNRECOGNIZED = -1,
}

export function iPProtoFromJSON(object: any): IPProto {
  switch (object) {
    case 0:
    case "ALL":
      return IPProto.ALL;
    case 6:
    case "TCP":
      return IPProto.TCP;
    case 17:
    case "UDP":
      return IPProto.UDP;
    case 1:
    case "ICMPv4":
      return IPProto.ICMPv4;
    case 58:
    case "ICMPv6":
      return IPProto.ICMPv6;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IPProto.UNRECOGNIZED;
  }
}

export function iPProtoToJSON(object: IPProto): string {
  switch (object) {
    case IPProto.ALL:
      return "ALL";
    case IPProto.TCP:
      return "TCP";
    case IPProto.UDP:
      return "UDP";
    case IPProto.ICMPv4:
      return "ICMPv4";
    case IPProto.ICMPv6:
      return "ICMPv6";
    case IPProto.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NodeType {
  /** FLEET - servers */
  FLEET = 0,
  /** RESOURCE - server */
  RESOURCE = 1,
  /** GROUP - users */
  GROUP = 2,
  /** USER - user */
  USER = 3,
  /** INK - devices */
  INK = 4,
  /** DEVICE - device */
  DEVICE = 5,
  /** SUBNET_LINKER - subnet linker */
  SUBNET_LINKER = 6,
  UNRECOGNIZED = -1,
}

export function nodeTypeFromJSON(object: any): NodeType {
  switch (object) {
    case 0:
    case "FLEET":
      return NodeType.FLEET;
    case 1:
    case "RESOURCE":
      return NodeType.RESOURCE;
    case 2:
    case "GROUP":
      return NodeType.GROUP;
    case 3:
    case "USER":
      return NodeType.USER;
    case 4:
    case "INK":
      return NodeType.INK;
    case 5:
    case "DEVICE":
      return NodeType.DEVICE;
    case 6:
    case "SUBNET_LINKER":
      return NodeType.SUBNET_LINKER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType.UNRECOGNIZED;
  }
}

export function nodeTypeToJSON(object: NodeType): string {
  switch (object) {
    case NodeType.FLEET:
      return "FLEET";
    case NodeType.RESOURCE:
      return "RESOURCE";
    case NodeType.GROUP:
      return "GROUP";
    case NodeType.USER:
      return "USER";
    case NodeType.INK:
      return "INK";
    case NodeType.DEVICE:
      return "DEVICE";
    case NodeType.SUBNET_LINKER:
      return "SUBNET_LINKER";
    case NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LinkerType {
  SUBNET = 0,
  UNIVERSAL = 1,
  APP = 2,
  UNRECOGNIZED = -1,
}

export function linkerTypeFromJSON(object: any): LinkerType {
  switch (object) {
    case 0:
    case "SUBNET":
      return LinkerType.SUBNET;
    case 1:
    case "UNIVERSAL":
      return LinkerType.UNIVERSAL;
    case 2:
    case "APP":
      return LinkerType.APP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LinkerType.UNRECOGNIZED;
  }
}

export function linkerTypeToJSON(object: LinkerType): string {
  switch (object) {
    case LinkerType.SUBNET:
      return "SUBNET";
    case LinkerType.UNIVERSAL:
      return "UNIVERSAL";
    case LinkerType.APP:
      return "APP";
    case LinkerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserRole {
  OWNER = 0,
  ADMIN = 1,
  MEMBER = 2,
  UNRECOGNIZED = -1,
}

export function userRoleFromJSON(object: any): UserRole {
  switch (object) {
    case 0:
    case "OWNER":
      return UserRole.OWNER;
    case 1:
    case "ADMIN":
      return UserRole.ADMIN;
    case 2:
    case "MEMBER":
      return UserRole.MEMBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserRole.UNRECOGNIZED;
  }
}

export function userRoleToJSON(object: UserRole): string {
  switch (object) {
    case UserRole.OWNER:
      return "OWNER";
    case UserRole.ADMIN:
      return "ADMIN";
    case UserRole.MEMBER:
      return "MEMBER";
    case UserRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExpirelyTime {
  /** ONEMONTH - 30days */
  ONEMONTH = 0,
  /** TWOMONTH - 60days */
  TWOMONTH = 1,
  /** THREEMONTH - 90days */
  THREEMONTH = 2,
  UNRECOGNIZED = -1,
}

export function expirelyTimeFromJSON(object: any): ExpirelyTime {
  switch (object) {
    case 0:
    case "ONEMONTH":
      return ExpirelyTime.ONEMONTH;
    case 1:
    case "TWOMONTH":
      return ExpirelyTime.TWOMONTH;
    case 2:
    case "THREEMONTH":
      return ExpirelyTime.THREEMONTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExpirelyTime.UNRECOGNIZED;
  }
}

export function expirelyTimeToJSON(object: ExpirelyTime): string {
  switch (object) {
    case ExpirelyTime.ONEMONTH:
      return "ONEMONTH";
    case ExpirelyTime.TWOMONTH:
      return "TWOMONTH";
    case ExpirelyTime.THREEMONTH:
      return "THREEMONTH";
    case ExpirelyTime.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Platform {
  DOCKER = 0,
  CLI = 1,
  LINUX = 2,
  GCP = 3,
  MANUAL = 4,
  AWS = 5,
  AZURE = 6,
  ONPREM = 7,
  MACOS = 8,
  WINDOWS = 9,
  ONBOARDING = 10,
  OTHER = 11,
  UNRECOGNIZED = -1,
}

export function platformFromJSON(object: any): Platform {
  switch (object) {
    case 0:
    case "DOCKER":
      return Platform.DOCKER;
    case 1:
    case "CLI":
      return Platform.CLI;
    case 2:
    case "LINUX":
      return Platform.LINUX;
    case 3:
    case "GCP":
      return Platform.GCP;
    case 4:
    case "MANUAL":
      return Platform.MANUAL;
    case 5:
    case "AWS":
      return Platform.AWS;
    case 6:
    case "AZURE":
      return Platform.AZURE;
    case 7:
    case "ONPREM":
      return Platform.ONPREM;
    case 8:
    case "MACOS":
      return Platform.MACOS;
    case 9:
    case "WINDOWS":
      return Platform.WINDOWS;
    case 10:
    case "ONBOARDING":
      return Platform.ONBOARDING;
    case 11:
    case "OTHER":
      return Platform.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Platform.UNRECOGNIZED;
  }
}

export function platformToJSON(object: Platform): string {
  switch (object) {
    case Platform.DOCKER:
      return "DOCKER";
    case Platform.CLI:
      return "CLI";
    case Platform.LINUX:
      return "LINUX";
    case Platform.GCP:
      return "GCP";
    case Platform.MANUAL:
      return "MANUAL";
    case Platform.AWS:
      return "AWS";
    case Platform.AZURE:
      return "AZURE";
    case Platform.ONPREM:
      return "ONPREM";
    case Platform.MACOS:
      return "MACOS";
    case Platform.WINDOWS:
      return "WINDOWS";
    case Platform.ONBOARDING:
      return "ONBOARDING";
    case Platform.OTHER:
      return "OTHER";
    case Platform.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateAclRequest {
  name: string;
  desc: string;
  /** user ids */
  src: AclResources[];
  /** user ids */
  dst: AclResources[];
  /**
   * ianaのプロトコル番号で実装
   * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
   * 0の場合はTCP, UDP, ICMPv4,ICMPv6が有効になる
   */
  ipProto: IPProto[];
  ports: string;
}

export interface AclResources {
  nodeIds: number[];
  /** for fleet or group or ink or linker */
  policyId: string;
  nodeType: NodeType;
}

export interface PatchAclRequest {
  id: string;
  name?: string | undefined;
  desc?: string | undefined;
  src: AclResources[];
  dst: AclResources[];
  /**
   * ianaのプロトコル番号を使用する
   * 0の場合はTCP, UDP, ICMPv4,ICMPv6が有効になる
   */
  ipProto: IPProto[];
  ports?: string | undefined;
}

export interface GetAclRequest {
  id: string;
}

export interface GetAclsResponse {
  acls: AclResponse[];
}

export interface GetAclsJsonResponse {
  json: string;
}

export interface AclResponse {
  id: string;
  name: string;
  desc: string;
  src: Policy | undefined;
  dst: Policy | undefined;
  ipProto: IPProto[];
  ports: string;
  updatedAt: string;
  aclType: string;
}

export interface GetMeResponse {
  username: string;
  email: string;
  picture: string;
  isOwner: boolean;
}

export interface GetUserRequest {
  nodeId: number;
}

export interface GetUsersRequest {
  groupId?: string | undefined;
}

export interface PatchUserRequest {
  id: string;
  role: UserRole;
}

export interface Users {
  users: User[];
}

export interface CreateGroupRequest {
  name: string;
  desc: string;
  nodeIds: number[];
}

export interface GetGroupRequest {
  id: string;
}

export interface Groups {
  groups: Group[];
}

export interface UserWithPicture {
  /** user id */
  id: string;
  /** user name */
  name: string;
  /** picture url */
  picture: string;
}

export interface PatchGroupRequest {
  id: string;
  name?: string | undefined;
  desc?:
    | string
    | undefined;
  /** device id or user id (common node ids) */
  nodeIds: number[];
}

export interface GetDeviceRequest {
  /** node id */
  nodeId: number;
}

export interface GetDevicesRequest {
  /** このパラメータがある場合は、レスポンスから、そのidをひく */
  inkId?: string | undefined;
}

export interface Devices {
  devices: Device[];
}

export interface CreateInkRequest {
  name: string;
  desc: string;
  /** device id or user id (common node ids) */
  nodeIds: number[];
}

export interface GetInkRequest {
  id: string;
}

export interface PatchInkRequest {
  id: string;
  name?: string | undefined;
  desc?:
    | string
    | undefined;
  /** device id or user id (common node ids) */
  nodeIds: number[];
}

export interface Inks {
  inks: Ink[];
}

export interface Ink {
  id: string;
  name: string;
  desc: string;
  domain: string;
  devices: Device[];
  ports: string;
  updatedAt: string;
}

export interface GenerateComposeKeyRequest {
  platform: Platform;
  expirelyTime: ExpirelyTime;
  name: string;
  desc: string;
  isReusable: boolean;
}

export interface GenerateComposeKeyResponse {
  installScripts: GenerateComposeKeyResponse_installScript[];
  composeKey: string;
}

export interface GenerateComposeKeyResponse_installScript {
  script: string;
  platform: Platform;
}

export interface GetComposeKeysResponse {
  composeKeys: GetComposeKeysResponse_composeKey[];
}

export interface GetComposeKeysResponse_composeKey {
  composeKey: string;
  expiredAt: string;
  hasExpied: boolean;
  createdBy: string;
  createdAt: string;
  description: string;
  isReusable: boolean;
}

export interface GetComposeNodeStatusRequest {
  composeKey: string;
}

export interface GetComposeNodeStatusResponse {
  isConnected: boolean;
  ip: string;
  host: string;
}

export interface GetResourceRequest {
  nodeId: number;
}

export interface GetResourcesRequest {
  fleetId?: string | undefined;
}

export interface Resources {
  resources: Resource[];
}

export interface CreateFleetRequest {
  name: string;
  desc: string;
  nodeIds: number[];
  platform: Platform;
  ports: string;
  ipProto: IPProto[];
}

export interface GetFleetRequest {
  id: string;
}

export interface Fleets {
  fleets: Fleet[];
}

export interface PatchFleetRequest {
  id: string;
  name?: string | undefined;
  desc?:
    | string
    | undefined;
  /** resource ids */
  nodeIds: number[];
  platform?: Platform | undefined;
  ports?: string | undefined;
}

export interface Overview {
  devicesAmount: number;
  usersAmount: number;
  fleetsAmount: number;
  resourcesAmount: number;
  isOnboarding: boolean;
  /** invite new user */
  inviteLink: string;
}

export interface InviteUserResponse {
  inviteCode: string;
}

export interface CreateSubnetLinkerRequest {
  nodeId: number;
  name: string;
  desc: string;
  /** 192.168.0.0/24, 192.154.0.0/24 */
  advertisedRoutes: string[];
}

export interface GetSubnetLinkerConvertibleNodesResponse {
  resources: Resource[];
  devices: Device[];
}

export interface PatchSubnetLinkerRequest {
  id: string;
  name?: string | undefined;
  desc?:
    | string
    | undefined;
  /** 192.168.0.0/24, 192.154.0.0/24 */
  advertisedRoutes: string[];
}

export interface GetSubnetLinkersReponse {
  linkers: Linker[];
}

export interface Linker {
  id: string;
  linkerType: LinkerType;
  nodeId: number;
  /** minor change 0.0.1 currently device or resource */
  nodeType: NodeType;
  name: string;
  desc: string;
  email: string;
  domain: string;
  ip: string;
  /** 192.168.0.0/24, 192.154.0.0/24 */
  advertisedRoutes: string[];
  host: string;
  os: string;
  nodeKey: string;
  platform: Platform;
  createdBy: string;
  createdAt: string;
  status: boolean;
  lastSeen: string;
}

export interface CreateSubnetLinkerResponse {
  id: string;
  nodeId: number;
  name: string;
  desc: string;
  /** 192.168.0.0/24, 192.154.0.0/24 */
  advertisedRoutes: string[];
}

export interface PatchSubnetLinkerResponse {
  id: string;
  nodeIds: number;
  name: string;
  desc: string;
  /** 192.168.0.0/24, 192.154.0.0/24 */
  advertisedRoutes: string[];
}

export interface Policy {
  fleets: Fleet[];
  resources: Resource[];
  groups: Group[];
  users: User[];
  inks: Ink[];
  devices: Device[];
  linkers: Linker[];
}

export interface Fleet {
  id: string;
  name: string;
  desc: string;
  resources: Resource[];
  ipProto: IPProto[];
  ports: string;
  updatedAt: string;
  platform: Platform;
  createdBy: string;
}

export interface Resource {
  id: string;
  nodeId: number;
  name: string;
  email: string;
  ip: string;
  ports: string;
  ipProto: IPProto[];
  os: string;
  platform: Platform;
  status: boolean;
  createdBy: string;
  lastSeen: string;
  isLinker: boolean;
  linker?:
    | Linker
    | undefined;
  /** 属しているfleetが返ってくる */
  fleets: Fleet[];
}

export interface Group {
  id: string;
  name: string;
  desc: string;
  users: User[];
  updatedAt: string;
}

export interface User {
  nodeId: number;
  name: string;
  picture: string;
  email: string;
  role: string;
  joined: string;
  /** only when status false */
  lastSeen: string;
  status: boolean;
  groups: Group[];
  devices: Device[];
  resources: Resource[];
  fleets: Fleet[];
  inks: Ink[];
}

export interface Device {
  nodeId: number;
  name: string;
  email: string;
  ip: string;
  ports: string;
  os: string;
  status: boolean;
  /** only when status false */
  lastSeen: string;
  createdBy: string;
  version: string;
  nodeKey: string;
  createdAt: string;
  keyExpiry: string;
  isLinker: boolean;
  linker?:
    | Linker
    | undefined;
  /** deviceが属しているinks */
  inks: Ink[];
}

function createBaseCreateAclRequest(): CreateAclRequest {
  return { name: "", desc: "", src: [], dst: [], ipProto: [], ports: "" };
}

export const CreateAclRequest: MessageFns<CreateAclRequest> = {
  encode(message: CreateAclRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(18).string(message.desc);
    }
    for (const v of message.src) {
      AclResources.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.dst) {
      AclResources.encode(v!, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.ipProto) {
      writer.int32(v);
    }
    writer.join();
    if (message.ports !== "") {
      writer.uint32(50).string(message.ports);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAclRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAclRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.src.push(AclResources.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dst.push(AclResources.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag === 40) {
            message.ipProto.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ipProto.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ports = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAclRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      src: globalThis.Array.isArray(object?.src) ? object.src.map((e: any) => AclResources.fromJSON(e)) : [],
      dst: globalThis.Array.isArray(object?.dst) ? object.dst.map((e: any) => AclResources.fromJSON(e)) : [],
      ipProto: globalThis.Array.isArray(object?.ipProto) ? object.ipProto.map((e: any) => iPProtoFromJSON(e)) : [],
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
    };
  },

  toJSON(message: CreateAclRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.src?.length) {
      obj.src = message.src.map((e) => AclResources.toJSON(e));
    }
    if (message.dst?.length) {
      obj.dst = message.dst.map((e) => AclResources.toJSON(e));
    }
    if (message.ipProto?.length) {
      obj.ipProto = message.ipProto.map((e) => iPProtoToJSON(e));
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAclRequest>, I>>(base?: I): CreateAclRequest {
    return CreateAclRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAclRequest>, I>>(object: I): CreateAclRequest {
    const message = createBaseCreateAclRequest();
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.src = object.src?.map((e) => AclResources.fromPartial(e)) || [];
    message.dst = object.dst?.map((e) => AclResources.fromPartial(e)) || [];
    message.ipProto = object.ipProto?.map((e) => e) || [];
    message.ports = object.ports ?? "";
    return message;
  },
};

function createBaseAclResources(): AclResources {
  return { nodeIds: [], policyId: "", nodeType: 0 };
}

export const AclResources: MessageFns<AclResources> = {
  encode(message: AclResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    if (message.policyId !== "") {
      writer.uint32(18).string(message.policyId);
    }
    if (message.nodeType !== 0) {
      writer.uint32(24).int32(message.nodeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AclResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAclResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AclResources {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      nodeType: isSet(object.nodeType) ? nodeTypeFromJSON(object.nodeType) : 0,
    };
  },

  toJSON(message: AclResources): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.nodeType !== 0) {
      obj.nodeType = nodeTypeToJSON(message.nodeType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AclResources>, I>>(base?: I): AclResources {
    return AclResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AclResources>, I>>(object: I): AclResources {
    const message = createBaseAclResources();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.policyId = object.policyId ?? "";
    message.nodeType = object.nodeType ?? 0;
    return message;
  },
};

function createBasePatchAclRequest(): PatchAclRequest {
  return { id: "", name: undefined, desc: undefined, src: [], dst: [], ipProto: [], ports: undefined };
}

export const PatchAclRequest: MessageFns<PatchAclRequest> = {
  encode(message: PatchAclRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== undefined) {
      writer.uint32(26).string(message.desc);
    }
    for (const v of message.src) {
      AclResources.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.dst) {
      AclResources.encode(v!, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.ipProto) {
      writer.int32(v);
    }
    writer.join();
    if (message.ports !== undefined) {
      writer.uint32(58).string(message.ports);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAclRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAclRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.src.push(AclResources.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dst.push(AclResources.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag === 48) {
            message.ipProto.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ipProto.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ports = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAclRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      desc: isSet(object.desc) ? globalThis.String(object.desc) : undefined,
      src: globalThis.Array.isArray(object?.src) ? object.src.map((e: any) => AclResources.fromJSON(e)) : [],
      dst: globalThis.Array.isArray(object?.dst) ? object.dst.map((e: any) => AclResources.fromJSON(e)) : [],
      ipProto: globalThis.Array.isArray(object?.ipProto) ? object.ipProto.map((e: any) => iPProtoFromJSON(e)) : [],
      ports: isSet(object.ports) ? globalThis.String(object.ports) : undefined,
    };
  },

  toJSON(message: PatchAclRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.desc !== undefined) {
      obj.desc = message.desc;
    }
    if (message.src?.length) {
      obj.src = message.src.map((e) => AclResources.toJSON(e));
    }
    if (message.dst?.length) {
      obj.dst = message.dst.map((e) => AclResources.toJSON(e));
    }
    if (message.ipProto?.length) {
      obj.ipProto = message.ipProto.map((e) => iPProtoToJSON(e));
    }
    if (message.ports !== undefined) {
      obj.ports = message.ports;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAclRequest>, I>>(base?: I): PatchAclRequest {
    return PatchAclRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAclRequest>, I>>(object: I): PatchAclRequest {
    const message = createBasePatchAclRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.desc = object.desc ?? undefined;
    message.src = object.src?.map((e) => AclResources.fromPartial(e)) || [];
    message.dst = object.dst?.map((e) => AclResources.fromPartial(e)) || [];
    message.ipProto = object.ipProto?.map((e) => e) || [];
    message.ports = object.ports ?? undefined;
    return message;
  },
};

function createBaseGetAclRequest(): GetAclRequest {
  return { id: "" };
}

export const GetAclRequest: MessageFns<GetAclRequest> = {
  encode(message: GetAclRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAclRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAclRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAclRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetAclRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAclRequest>, I>>(base?: I): GetAclRequest {
    return GetAclRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAclRequest>, I>>(object: I): GetAclRequest {
    const message = createBaseGetAclRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetAclsResponse(): GetAclsResponse {
  return { acls: [] };
}

export const GetAclsResponse: MessageFns<GetAclsResponse> = {
  encode(message: GetAclsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.acls) {
      AclResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAclsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAclsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acls.push(AclResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAclsResponse {
    return { acls: globalThis.Array.isArray(object?.acls) ? object.acls.map((e: any) => AclResponse.fromJSON(e)) : [] };
  },

  toJSON(message: GetAclsResponse): unknown {
    const obj: any = {};
    if (message.acls?.length) {
      obj.acls = message.acls.map((e) => AclResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAclsResponse>, I>>(base?: I): GetAclsResponse {
    return GetAclsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAclsResponse>, I>>(object: I): GetAclsResponse {
    const message = createBaseGetAclsResponse();
    message.acls = object.acls?.map((e) => AclResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAclsJsonResponse(): GetAclsJsonResponse {
  return { json: "" };
}

export const GetAclsJsonResponse: MessageFns<GetAclsJsonResponse> = {
  encode(message: GetAclsJsonResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.json !== "") {
      writer.uint32(10).string(message.json);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAclsJsonResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAclsJsonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.json = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAclsJsonResponse {
    return { json: isSet(object.json) ? globalThis.String(object.json) : "" };
  },

  toJSON(message: GetAclsJsonResponse): unknown {
    const obj: any = {};
    if (message.json !== "") {
      obj.json = message.json;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAclsJsonResponse>, I>>(base?: I): GetAclsJsonResponse {
    return GetAclsJsonResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAclsJsonResponse>, I>>(object: I): GetAclsJsonResponse {
    const message = createBaseGetAclsJsonResponse();
    message.json = object.json ?? "";
    return message;
  },
};

function createBaseAclResponse(): AclResponse {
  return {
    id: "",
    name: "",
    desc: "",
    src: undefined,
    dst: undefined,
    ipProto: [],
    ports: "",
    updatedAt: "",
    aclType: "",
  };
}

export const AclResponse: MessageFns<AclResponse> = {
  encode(message: AclResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    if (message.src !== undefined) {
      Policy.encode(message.src, writer.uint32(34).fork()).join();
    }
    if (message.dst !== undefined) {
      Policy.encode(message.dst, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.ipProto) {
      writer.int32(v);
    }
    writer.join();
    if (message.ports !== "") {
      writer.uint32(58).string(message.ports);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    if (message.aclType !== "") {
      writer.uint32(74).string(message.aclType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AclResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAclResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.src = Policy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dst = Policy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag === 48) {
            message.ipProto.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ipProto.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ports = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.aclType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AclResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      src: isSet(object.src) ? Policy.fromJSON(object.src) : undefined,
      dst: isSet(object.dst) ? Policy.fromJSON(object.dst) : undefined,
      ipProto: globalThis.Array.isArray(object?.ipProto) ? object.ipProto.map((e: any) => iPProtoFromJSON(e)) : [],
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      aclType: isSet(object.aclType) ? globalThis.String(object.aclType) : "",
    };
  },

  toJSON(message: AclResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.src !== undefined) {
      obj.src = Policy.toJSON(message.src);
    }
    if (message.dst !== undefined) {
      obj.dst = Policy.toJSON(message.dst);
    }
    if (message.ipProto?.length) {
      obj.ipProto = message.ipProto.map((e) => iPProtoToJSON(e));
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.aclType !== "") {
      obj.aclType = message.aclType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AclResponse>, I>>(base?: I): AclResponse {
    return AclResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AclResponse>, I>>(object: I): AclResponse {
    const message = createBaseAclResponse();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.src = (object.src !== undefined && object.src !== null) ? Policy.fromPartial(object.src) : undefined;
    message.dst = (object.dst !== undefined && object.dst !== null) ? Policy.fromPartial(object.dst) : undefined;
    message.ipProto = object.ipProto?.map((e) => e) || [];
    message.ports = object.ports ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.aclType = object.aclType ?? "";
    return message;
  },
};

function createBaseGetMeResponse(): GetMeResponse {
  return { username: "", email: "", picture: "", isOwner: false };
}

export const GetMeResponse: MessageFns<GetMeResponse> = {
  encode(message: GetMeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.picture !== "") {
      writer.uint32(26).string(message.picture);
    }
    if (message.isOwner !== false) {
      writer.uint32(32).bool(message.isOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.picture = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isOwner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMeResponse {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      picture: isSet(object.picture) ? globalThis.String(object.picture) : "",
      isOwner: isSet(object.isOwner) ? globalThis.Boolean(object.isOwner) : false,
    };
  },

  toJSON(message: GetMeResponse): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.picture !== "") {
      obj.picture = message.picture;
    }
    if (message.isOwner !== false) {
      obj.isOwner = message.isOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMeResponse>, I>>(base?: I): GetMeResponse {
    return GetMeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMeResponse>, I>>(object: I): GetMeResponse {
    const message = createBaseGetMeResponse();
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.picture = object.picture ?? "";
    message.isOwner = object.isOwner ?? false;
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { nodeId: 0 };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint64(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0 };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseGetUsersRequest(): GetUsersRequest {
  return { groupId: undefined };
}

export const GetUsersRequest: MessageFns<GetUsersRequest> = {
  encode(message: GetUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== undefined) {
      writer.uint32(10).string(message.groupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersRequest {
    return { groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : undefined };
  },

  toJSON(message: GetUsersRequest): unknown {
    const obj: any = {};
    if (message.groupId !== undefined) {
      obj.groupId = message.groupId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersRequest>, I>>(base?: I): GetUsersRequest {
    return GetUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersRequest>, I>>(object: I): GetUsersRequest {
    const message = createBaseGetUsersRequest();
    message.groupId = object.groupId ?? undefined;
    return message;
  },
};

function createBasePatchUserRequest(): PatchUserRequest {
  return { id: "", role: 0 };
}

export const PatchUserRequest: MessageFns<PatchUserRequest> = {
  encode(message: PatchUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchUserRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      role: isSet(object.role) ? userRoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: PatchUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.role !== 0) {
      obj.role = userRoleToJSON(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchUserRequest>, I>>(base?: I): PatchUserRequest {
    return PatchUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchUserRequest>, I>>(object: I): PatchUserRequest {
    const message = createBasePatchUserRequest();
    message.id = object.id ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseUsers(): Users {
  return { users: [] };
}

export const Users: MessageFns<Users> = {
  encode(message: Users, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Users {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Users {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: Users): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Users>, I>>(base?: I): Users {
    return Users.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Users>, I>>(object: I): Users {
    const message = createBaseUsers();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateGroupRequest(): CreateGroupRequest {
  return { name: "", desc: "", nodeIds: [] };
}

export const CreateGroupRequest: MessageFns<CreateGroupRequest> = {
  encode(message: CreateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(18).string(message.desc);
    }
    writer.uint32(26).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGroupRequest>, I>>(base?: I): CreateGroupRequest {
    return CreateGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGroupRequest>, I>>(object: I): CreateGroupRequest {
    const message = createBaseCreateGroupRequest();
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetGroupRequest(): GetGroupRequest {
  return { id: "" };
}

export const GetGroupRequest: MessageFns<GetGroupRequest> = {
  encode(message: GetGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetGroupRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupRequest>, I>>(base?: I): GetGroupRequest {
    return GetGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupRequest>, I>>(object: I): GetGroupRequest {
    const message = createBaseGetGroupRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGroups(): Groups {
  return { groups: [] };
}

export const Groups: MessageFns<Groups> = {
  encode(message: Groups, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Groups {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroups();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Groups {
    return { groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [] };
  },

  toJSON(message: Groups): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Groups>, I>>(base?: I): Groups {
    return Groups.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Groups>, I>>(object: I): Groups {
    const message = createBaseGroups();
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserWithPicture(): UserWithPicture {
  return { id: "", name: "", picture: "" };
}

export const UserWithPicture: MessageFns<UserWithPicture> = {
  encode(message: UserWithPicture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.picture !== "") {
      writer.uint32(26).string(message.picture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserWithPicture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserWithPicture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.picture = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserWithPicture {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      picture: isSet(object.picture) ? globalThis.String(object.picture) : "",
    };
  },

  toJSON(message: UserWithPicture): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.picture !== "") {
      obj.picture = message.picture;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserWithPicture>, I>>(base?: I): UserWithPicture {
    return UserWithPicture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserWithPicture>, I>>(object: I): UserWithPicture {
    const message = createBaseUserWithPicture();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.picture = object.picture ?? "";
    return message;
  },
};

function createBasePatchGroupRequest(): PatchGroupRequest {
  return { id: "", name: undefined, desc: undefined, nodeIds: [] };
}

export const PatchGroupRequest: MessageFns<PatchGroupRequest> = {
  encode(message: PatchGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== undefined) {
      writer.uint32(26).string(message.desc);
    }
    writer.uint32(34).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchGroupRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      desc: isSet(object.desc) ? globalThis.String(object.desc) : undefined,
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: PatchGroupRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.desc !== undefined) {
      obj.desc = message.desc;
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchGroupRequest>, I>>(base?: I): PatchGroupRequest {
    return PatchGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchGroupRequest>, I>>(object: I): PatchGroupRequest {
    const message = createBasePatchGroupRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.desc = object.desc ?? undefined;
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDeviceRequest(): GetDeviceRequest {
  return { nodeId: 0 };
}

export const GetDeviceRequest: MessageFns<GetDeviceRequest> = {
  encode(message: GetDeviceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint64(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeviceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeviceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeviceRequest {
    return { nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0 };
  },

  toJSON(message: GetDeviceRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDeviceRequest>, I>>(base?: I): GetDeviceRequest {
    return GetDeviceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDeviceRequest>, I>>(object: I): GetDeviceRequest {
    const message = createBaseGetDeviceRequest();
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseGetDevicesRequest(): GetDevicesRequest {
  return { inkId: undefined };
}

export const GetDevicesRequest: MessageFns<GetDevicesRequest> = {
  encode(message: GetDevicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inkId !== undefined) {
      writer.uint32(10).string(message.inkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDevicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDevicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inkId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDevicesRequest {
    return { inkId: isSet(object.inkId) ? globalThis.String(object.inkId) : undefined };
  },

  toJSON(message: GetDevicesRequest): unknown {
    const obj: any = {};
    if (message.inkId !== undefined) {
      obj.inkId = message.inkId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDevicesRequest>, I>>(base?: I): GetDevicesRequest {
    return GetDevicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDevicesRequest>, I>>(object: I): GetDevicesRequest {
    const message = createBaseGetDevicesRequest();
    message.inkId = object.inkId ?? undefined;
    return message;
  },
};

function createBaseDevices(): Devices {
  return { devices: [] };
}

export const Devices: MessageFns<Devices> = {
  encode(message: Devices, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Devices {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevices();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Devices {
    return {
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
    };
  },

  toJSON(message: Devices): unknown {
    const obj: any = {};
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Devices>, I>>(base?: I): Devices {
    return Devices.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Devices>, I>>(object: I): Devices {
    const message = createBaseDevices();
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateInkRequest(): CreateInkRequest {
  return { name: "", desc: "", nodeIds: [] };
}

export const CreateInkRequest: MessageFns<CreateInkRequest> = {
  encode(message: CreateInkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(18).string(message.desc);
    }
    writer.uint32(26).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInkRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CreateInkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInkRequest>, I>>(base?: I): CreateInkRequest {
    return CreateInkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInkRequest>, I>>(object: I): CreateInkRequest {
    const message = createBaseCreateInkRequest();
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInkRequest(): GetInkRequest {
  return { id: "" };
}

export const GetInkRequest: MessageFns<GetInkRequest> = {
  encode(message: GetInkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInkRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetInkRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInkRequest>, I>>(base?: I): GetInkRequest {
    return GetInkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInkRequest>, I>>(object: I): GetInkRequest {
    const message = createBaseGetInkRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePatchInkRequest(): PatchInkRequest {
  return { id: "", name: undefined, desc: undefined, nodeIds: [] };
}

export const PatchInkRequest: MessageFns<PatchInkRequest> = {
  encode(message: PatchInkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== undefined) {
      writer.uint32(26).string(message.desc);
    }
    writer.uint32(34).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchInkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchInkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchInkRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      desc: isSet(object.desc) ? globalThis.String(object.desc) : undefined,
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: PatchInkRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.desc !== undefined) {
      obj.desc = message.desc;
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchInkRequest>, I>>(base?: I): PatchInkRequest {
    return PatchInkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchInkRequest>, I>>(object: I): PatchInkRequest {
    const message = createBasePatchInkRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.desc = object.desc ?? undefined;
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseInks(): Inks {
  return { inks: [] };
}

export const Inks: MessageFns<Inks> = {
  encode(message: Inks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inks) {
      Ink.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Inks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inks.push(Ink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Inks {
    return { inks: globalThis.Array.isArray(object?.inks) ? object.inks.map((e: any) => Ink.fromJSON(e)) : [] };
  },

  toJSON(message: Inks): unknown {
    const obj: any = {};
    if (message.inks?.length) {
      obj.inks = message.inks.map((e) => Ink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Inks>, I>>(base?: I): Inks {
    return Inks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Inks>, I>>(object: I): Inks {
    const message = createBaseInks();
    message.inks = object.inks?.map((e) => Ink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInk(): Ink {
  return { id: "", name: "", desc: "", domain: "", devices: [], ports: "", updatedAt: "" };
}

export const Ink: MessageFns<Ink> = {
  encode(message: Ink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    if (message.domain !== "") {
      writer.uint32(34).string(message.domain);
    }
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.ports !== "") {
      writer.uint32(58).string(message.ports);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ports = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ink {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Ink): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ink>, I>>(base?: I): Ink {
    return Ink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ink>, I>>(object: I): Ink {
    const message = createBaseInk();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.domain = object.domain ?? "";
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.ports = object.ports ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseGenerateComposeKeyRequest(): GenerateComposeKeyRequest {
  return { platform: 0, expirelyTime: 0, name: "", desc: "", isReusable: false };
}

export const GenerateComposeKeyRequest: MessageFns<GenerateComposeKeyRequest> = {
  encode(message: GenerateComposeKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== 0) {
      writer.uint32(8).int32(message.platform);
    }
    if (message.expirelyTime !== 0) {
      writer.uint32(16).int32(message.expirelyTime);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(34).string(message.desc);
    }
    if (message.isReusable !== false) {
      writer.uint32(40).bool(message.isReusable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateComposeKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateComposeKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expirelyTime = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isReusable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateComposeKeyRequest {
    return {
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      expirelyTime: isSet(object.expirelyTime) ? expirelyTimeFromJSON(object.expirelyTime) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      isReusable: isSet(object.isReusable) ? globalThis.Boolean(object.isReusable) : false,
    };
  },

  toJSON(message: GenerateComposeKeyRequest): unknown {
    const obj: any = {};
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.expirelyTime !== 0) {
      obj.expirelyTime = expirelyTimeToJSON(message.expirelyTime);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.isReusable !== false) {
      obj.isReusable = message.isReusable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateComposeKeyRequest>, I>>(base?: I): GenerateComposeKeyRequest {
    return GenerateComposeKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateComposeKeyRequest>, I>>(object: I): GenerateComposeKeyRequest {
    const message = createBaseGenerateComposeKeyRequest();
    message.platform = object.platform ?? 0;
    message.expirelyTime = object.expirelyTime ?? 0;
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.isReusable = object.isReusable ?? false;
    return message;
  },
};

function createBaseGenerateComposeKeyResponse(): GenerateComposeKeyResponse {
  return { installScripts: [], composeKey: "" };
}

export const GenerateComposeKeyResponse: MessageFns<GenerateComposeKeyResponse> = {
  encode(message: GenerateComposeKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.installScripts) {
      GenerateComposeKeyResponse_installScript.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.composeKey !== "") {
      writer.uint32(18).string(message.composeKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateComposeKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateComposeKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.installScripts.push(GenerateComposeKeyResponse_installScript.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.composeKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateComposeKeyResponse {
    return {
      installScripts: globalThis.Array.isArray(object?.installScripts)
        ? object.installScripts.map((e: any) => GenerateComposeKeyResponse_installScript.fromJSON(e))
        : [],
      composeKey: isSet(object.composeKey) ? globalThis.String(object.composeKey) : "",
    };
  },

  toJSON(message: GenerateComposeKeyResponse): unknown {
    const obj: any = {};
    if (message.installScripts?.length) {
      obj.installScripts = message.installScripts.map((e) => GenerateComposeKeyResponse_installScript.toJSON(e));
    }
    if (message.composeKey !== "") {
      obj.composeKey = message.composeKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateComposeKeyResponse>, I>>(base?: I): GenerateComposeKeyResponse {
    return GenerateComposeKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateComposeKeyResponse>, I>>(object: I): GenerateComposeKeyResponse {
    const message = createBaseGenerateComposeKeyResponse();
    message.installScripts =
      object.installScripts?.map((e) => GenerateComposeKeyResponse_installScript.fromPartial(e)) || [];
    message.composeKey = object.composeKey ?? "";
    return message;
  },
};

function createBaseGenerateComposeKeyResponse_installScript(): GenerateComposeKeyResponse_installScript {
  return { script: "", platform: 0 };
}

export const GenerateComposeKeyResponse_installScript: MessageFns<GenerateComposeKeyResponse_installScript> = {
  encode(message: GenerateComposeKeyResponse_installScript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.script !== "") {
      writer.uint32(10).string(message.script);
    }
    if (message.platform !== 0) {
      writer.uint32(16).int32(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateComposeKeyResponse_installScript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateComposeKeyResponse_installScript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.script = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateComposeKeyResponse_installScript {
    return {
      script: isSet(object.script) ? globalThis.String(object.script) : "",
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
    };
  },

  toJSON(message: GenerateComposeKeyResponse_installScript): unknown {
    const obj: any = {};
    if (message.script !== "") {
      obj.script = message.script;
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateComposeKeyResponse_installScript>, I>>(
    base?: I,
  ): GenerateComposeKeyResponse_installScript {
    return GenerateComposeKeyResponse_installScript.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateComposeKeyResponse_installScript>, I>>(
    object: I,
  ): GenerateComposeKeyResponse_installScript {
    const message = createBaseGenerateComposeKeyResponse_installScript();
    message.script = object.script ?? "";
    message.platform = object.platform ?? 0;
    return message;
  },
};

function createBaseGetComposeKeysResponse(): GetComposeKeysResponse {
  return { composeKeys: [] };
}

export const GetComposeKeysResponse: MessageFns<GetComposeKeysResponse> = {
  encode(message: GetComposeKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.composeKeys) {
      GetComposeKeysResponse_composeKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetComposeKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetComposeKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.composeKeys.push(GetComposeKeysResponse_composeKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetComposeKeysResponse {
    return {
      composeKeys: globalThis.Array.isArray(object?.composeKeys)
        ? object.composeKeys.map((e: any) => GetComposeKeysResponse_composeKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetComposeKeysResponse): unknown {
    const obj: any = {};
    if (message.composeKeys?.length) {
      obj.composeKeys = message.composeKeys.map((e) => GetComposeKeysResponse_composeKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetComposeKeysResponse>, I>>(base?: I): GetComposeKeysResponse {
    return GetComposeKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetComposeKeysResponse>, I>>(object: I): GetComposeKeysResponse {
    const message = createBaseGetComposeKeysResponse();
    message.composeKeys = object.composeKeys?.map((e) => GetComposeKeysResponse_composeKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetComposeKeysResponse_composeKey(): GetComposeKeysResponse_composeKey {
  return {
    composeKey: "",
    expiredAt: "",
    hasExpied: false,
    createdBy: "",
    createdAt: "",
    description: "",
    isReusable: false,
  };
}

export const GetComposeKeysResponse_composeKey: MessageFns<GetComposeKeysResponse_composeKey> = {
  encode(message: GetComposeKeysResponse_composeKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.composeKey !== "") {
      writer.uint32(10).string(message.composeKey);
    }
    if (message.expiredAt !== "") {
      writer.uint32(18).string(message.expiredAt);
    }
    if (message.hasExpied !== false) {
      writer.uint32(24).bool(message.hasExpied);
    }
    if (message.createdBy !== "") {
      writer.uint32(34).string(message.createdBy);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.isReusable !== false) {
      writer.uint32(56).bool(message.isReusable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetComposeKeysResponse_composeKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetComposeKeysResponse_composeKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.composeKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expiredAt = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hasExpied = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isReusable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetComposeKeysResponse_composeKey {
    return {
      composeKey: isSet(object.composeKey) ? globalThis.String(object.composeKey) : "",
      expiredAt: isSet(object.expiredAt) ? globalThis.String(object.expiredAt) : "",
      hasExpied: isSet(object.hasExpied) ? globalThis.Boolean(object.hasExpied) : false,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isReusable: isSet(object.isReusable) ? globalThis.Boolean(object.isReusable) : false,
    };
  },

  toJSON(message: GetComposeKeysResponse_composeKey): unknown {
    const obj: any = {};
    if (message.composeKey !== "") {
      obj.composeKey = message.composeKey;
    }
    if (message.expiredAt !== "") {
      obj.expiredAt = message.expiredAt;
    }
    if (message.hasExpied !== false) {
      obj.hasExpied = message.hasExpied;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isReusable !== false) {
      obj.isReusable = message.isReusable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetComposeKeysResponse_composeKey>, I>>(
    base?: I,
  ): GetComposeKeysResponse_composeKey {
    return GetComposeKeysResponse_composeKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetComposeKeysResponse_composeKey>, I>>(
    object: I,
  ): GetComposeKeysResponse_composeKey {
    const message = createBaseGetComposeKeysResponse_composeKey();
    message.composeKey = object.composeKey ?? "";
    message.expiredAt = object.expiredAt ?? "";
    message.hasExpied = object.hasExpied ?? false;
    message.createdBy = object.createdBy ?? "";
    message.createdAt = object.createdAt ?? "";
    message.description = object.description ?? "";
    message.isReusable = object.isReusable ?? false;
    return message;
  },
};

function createBaseGetComposeNodeStatusRequest(): GetComposeNodeStatusRequest {
  return { composeKey: "" };
}

export const GetComposeNodeStatusRequest: MessageFns<GetComposeNodeStatusRequest> = {
  encode(message: GetComposeNodeStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.composeKey !== "") {
      writer.uint32(10).string(message.composeKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetComposeNodeStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetComposeNodeStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.composeKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetComposeNodeStatusRequest {
    return { composeKey: isSet(object.composeKey) ? globalThis.String(object.composeKey) : "" };
  },

  toJSON(message: GetComposeNodeStatusRequest): unknown {
    const obj: any = {};
    if (message.composeKey !== "") {
      obj.composeKey = message.composeKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetComposeNodeStatusRequest>, I>>(base?: I): GetComposeNodeStatusRequest {
    return GetComposeNodeStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetComposeNodeStatusRequest>, I>>(object: I): GetComposeNodeStatusRequest {
    const message = createBaseGetComposeNodeStatusRequest();
    message.composeKey = object.composeKey ?? "";
    return message;
  },
};

function createBaseGetComposeNodeStatusResponse(): GetComposeNodeStatusResponse {
  return { isConnected: false, ip: "", host: "" };
}

export const GetComposeNodeStatusResponse: MessageFns<GetComposeNodeStatusResponse> = {
  encode(message: GetComposeNodeStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isConnected !== false) {
      writer.uint32(8).bool(message.isConnected);
    }
    if (message.ip !== "") {
      writer.uint32(18).string(message.ip);
    }
    if (message.host !== "") {
      writer.uint32(26).string(message.host);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetComposeNodeStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetComposeNodeStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isConnected = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.host = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetComposeNodeStatusResponse {
    return {
      isConnected: isSet(object.isConnected) ? globalThis.Boolean(object.isConnected) : false,
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
    };
  },

  toJSON(message: GetComposeNodeStatusResponse): unknown {
    const obj: any = {};
    if (message.isConnected !== false) {
      obj.isConnected = message.isConnected;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetComposeNodeStatusResponse>, I>>(base?: I): GetComposeNodeStatusResponse {
    return GetComposeNodeStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetComposeNodeStatusResponse>, I>>(object: I): GetComposeNodeStatusResponse {
    const message = createBaseGetComposeNodeStatusResponse();
    message.isConnected = object.isConnected ?? false;
    message.ip = object.ip ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseGetResourceRequest(): GetResourceRequest {
  return { nodeId: 0 };
}

export const GetResourceRequest: MessageFns<GetResourceRequest> = {
  encode(message: GetResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint64(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourceRequest {
    return { nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0 };
  },

  toJSON(message: GetResourceRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourceRequest>, I>>(base?: I): GetResourceRequest {
    return GetResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResourceRequest>, I>>(object: I): GetResourceRequest {
    const message = createBaseGetResourceRequest();
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseGetResourcesRequest(): GetResourcesRequest {
  return { fleetId: undefined };
}

export const GetResourcesRequest: MessageFns<GetResourcesRequest> = {
  encode(message: GetResourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fleetId !== undefined) {
      writer.uint32(10).string(message.fleetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fleetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourcesRequest {
    return { fleetId: isSet(object.fleetId) ? globalThis.String(object.fleetId) : undefined };
  },

  toJSON(message: GetResourcesRequest): unknown {
    const obj: any = {};
    if (message.fleetId !== undefined) {
      obj.fleetId = message.fleetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourcesRequest>, I>>(base?: I): GetResourcesRequest {
    return GetResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResourcesRequest>, I>>(object: I): GetResourcesRequest {
    const message = createBaseGetResourcesRequest();
    message.fleetId = object.fleetId ?? undefined;
    return message;
  },
};

function createBaseResources(): Resources {
  return { resources: [] };
}

export const Resources: MessageFns<Resources> = {
  encode(message: Resources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resources {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Resources): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resources>, I>>(base?: I): Resources {
    return Resources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resources>, I>>(object: I): Resources {
    const message = createBaseResources();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateFleetRequest(): CreateFleetRequest {
  return { name: "", desc: "", nodeIds: [], platform: 0, ports: "", ipProto: [] };
}

export const CreateFleetRequest: MessageFns<CreateFleetRequest> = {
  encode(message: CreateFleetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(18).string(message.desc);
    }
    writer.uint32(26).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    if (message.platform !== 0) {
      writer.uint32(32).int32(message.platform);
    }
    if (message.ports !== "") {
      writer.uint32(50).string(message.ports);
    }
    writer.uint32(58).fork();
    for (const v of message.ipProto) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFleetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFleetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ports = reader.string();
          continue;
        case 7:
          if (tag === 56) {
            message.ipProto.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ipProto.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFleetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
      ipProto: globalThis.Array.isArray(object?.ipProto) ? object.ipProto.map((e: any) => iPProtoFromJSON(e)) : [],
    };
  },

  toJSON(message: CreateFleetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    if (message.ipProto?.length) {
      obj.ipProto = message.ipProto.map((e) => iPProtoToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFleetRequest>, I>>(base?: I): CreateFleetRequest {
    return CreateFleetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFleetRequest>, I>>(object: I): CreateFleetRequest {
    const message = createBaseCreateFleetRequest();
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.platform = object.platform ?? 0;
    message.ports = object.ports ?? "";
    message.ipProto = object.ipProto?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetFleetRequest(): GetFleetRequest {
  return { id: "" };
}

export const GetFleetRequest: MessageFns<GetFleetRequest> = {
  encode(message: GetFleetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFleetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFleetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFleetRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetFleetRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFleetRequest>, I>>(base?: I): GetFleetRequest {
    return GetFleetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFleetRequest>, I>>(object: I): GetFleetRequest {
    const message = createBaseGetFleetRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseFleets(): Fleets {
  return { fleets: [] };
}

export const Fleets: MessageFns<Fleets> = {
  encode(message: Fleets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fleets) {
      Fleet.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fleets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFleets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fleets.push(Fleet.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fleets {
    return { fleets: globalThis.Array.isArray(object?.fleets) ? object.fleets.map((e: any) => Fleet.fromJSON(e)) : [] };
  },

  toJSON(message: Fleets): unknown {
    const obj: any = {};
    if (message.fleets?.length) {
      obj.fleets = message.fleets.map((e) => Fleet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fleets>, I>>(base?: I): Fleets {
    return Fleets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fleets>, I>>(object: I): Fleets {
    const message = createBaseFleets();
    message.fleets = object.fleets?.map((e) => Fleet.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchFleetRequest(): PatchFleetRequest {
  return { id: "", name: undefined, desc: undefined, nodeIds: [], platform: undefined, ports: undefined };
}

export const PatchFleetRequest: MessageFns<PatchFleetRequest> = {
  encode(message: PatchFleetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== undefined) {
      writer.uint32(26).string(message.desc);
    }
    writer.uint32(34).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.join();
    if (message.platform !== undefined) {
      writer.uint32(40).int32(message.platform);
    }
    if (message.ports !== undefined) {
      writer.uint32(50).string(message.ports);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchFleetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchFleetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.nodeIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ports = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchFleetRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      desc: isSet(object.desc) ? globalThis.String(object.desc) : undefined,
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.Number(e)) : [],
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : undefined,
      ports: isSet(object.ports) ? globalThis.String(object.ports) : undefined,
    };
  },

  toJSON(message: PatchFleetRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.desc !== undefined) {
      obj.desc = message.desc;
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => Math.round(e));
    }
    if (message.platform !== undefined) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.ports !== undefined) {
      obj.ports = message.ports;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchFleetRequest>, I>>(base?: I): PatchFleetRequest {
    return PatchFleetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchFleetRequest>, I>>(object: I): PatchFleetRequest {
    const message = createBasePatchFleetRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.desc = object.desc ?? undefined;
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.platform = object.platform ?? undefined;
    message.ports = object.ports ?? undefined;
    return message;
  },
};

function createBaseOverview(): Overview {
  return { devicesAmount: 0, usersAmount: 0, fleetsAmount: 0, resourcesAmount: 0, isOnboarding: false, inviteLink: "" };
}

export const Overview: MessageFns<Overview> = {
  encode(message: Overview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.devicesAmount !== 0) {
      writer.uint32(8).uint64(message.devicesAmount);
    }
    if (message.usersAmount !== 0) {
      writer.uint32(16).uint64(message.usersAmount);
    }
    if (message.fleetsAmount !== 0) {
      writer.uint32(24).uint64(message.fleetsAmount);
    }
    if (message.resourcesAmount !== 0) {
      writer.uint32(32).uint64(message.resourcesAmount);
    }
    if (message.isOnboarding !== false) {
      writer.uint32(40).bool(message.isOnboarding);
    }
    if (message.inviteLink !== "") {
      writer.uint32(50).string(message.inviteLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.devicesAmount = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.usersAmount = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fleetsAmount = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.resourcesAmount = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isOnboarding = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inviteLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overview {
    return {
      devicesAmount: isSet(object.devicesAmount) ? globalThis.Number(object.devicesAmount) : 0,
      usersAmount: isSet(object.usersAmount) ? globalThis.Number(object.usersAmount) : 0,
      fleetsAmount: isSet(object.fleetsAmount) ? globalThis.Number(object.fleetsAmount) : 0,
      resourcesAmount: isSet(object.resourcesAmount) ? globalThis.Number(object.resourcesAmount) : 0,
      isOnboarding: isSet(object.isOnboarding) ? globalThis.Boolean(object.isOnboarding) : false,
      inviteLink: isSet(object.inviteLink) ? globalThis.String(object.inviteLink) : "",
    };
  },

  toJSON(message: Overview): unknown {
    const obj: any = {};
    if (message.devicesAmount !== 0) {
      obj.devicesAmount = Math.round(message.devicesAmount);
    }
    if (message.usersAmount !== 0) {
      obj.usersAmount = Math.round(message.usersAmount);
    }
    if (message.fleetsAmount !== 0) {
      obj.fleetsAmount = Math.round(message.fleetsAmount);
    }
    if (message.resourcesAmount !== 0) {
      obj.resourcesAmount = Math.round(message.resourcesAmount);
    }
    if (message.isOnboarding !== false) {
      obj.isOnboarding = message.isOnboarding;
    }
    if (message.inviteLink !== "") {
      obj.inviteLink = message.inviteLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Overview>, I>>(base?: I): Overview {
    return Overview.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Overview>, I>>(object: I): Overview {
    const message = createBaseOverview();
    message.devicesAmount = object.devicesAmount ?? 0;
    message.usersAmount = object.usersAmount ?? 0;
    message.fleetsAmount = object.fleetsAmount ?? 0;
    message.resourcesAmount = object.resourcesAmount ?? 0;
    message.isOnboarding = object.isOnboarding ?? false;
    message.inviteLink = object.inviteLink ?? "";
    return message;
  },
};

function createBaseInviteUserResponse(): InviteUserResponse {
  return { inviteCode: "" };
}

export const InviteUserResponse: MessageFns<InviteUserResponse> = {
  encode(message: InviteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inviteCode !== "") {
      writer.uint32(10).string(message.inviteCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inviteCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InviteUserResponse {
    return { inviteCode: isSet(object.inviteCode) ? globalThis.String(object.inviteCode) : "" };
  },

  toJSON(message: InviteUserResponse): unknown {
    const obj: any = {};
    if (message.inviteCode !== "") {
      obj.inviteCode = message.inviteCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InviteUserResponse>, I>>(base?: I): InviteUserResponse {
    return InviteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InviteUserResponse>, I>>(object: I): InviteUserResponse {
    const message = createBaseInviteUserResponse();
    message.inviteCode = object.inviteCode ?? "";
    return message;
  },
};

function createBaseCreateSubnetLinkerRequest(): CreateSubnetLinkerRequest {
  return { nodeId: 0, name: "", desc: "", advertisedRoutes: [] };
}

export const CreateSubnetLinkerRequest: MessageFns<CreateSubnetLinkerRequest> = {
  encode(message: CreateSubnetLinkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    for (const v of message.advertisedRoutes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubnetLinkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubnetLinkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.advertisedRoutes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubnetLinkerRequest {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      advertisedRoutes: globalThis.Array.isArray(object?.advertisedRoutes)
        ? object.advertisedRoutes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateSubnetLinkerRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.advertisedRoutes?.length) {
      obj.advertisedRoutes = message.advertisedRoutes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSubnetLinkerRequest>, I>>(base?: I): CreateSubnetLinkerRequest {
    return CreateSubnetLinkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSubnetLinkerRequest>, I>>(object: I): CreateSubnetLinkerRequest {
    const message = createBaseCreateSubnetLinkerRequest();
    message.nodeId = object.nodeId ?? 0;
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.advertisedRoutes = object.advertisedRoutes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSubnetLinkerConvertibleNodesResponse(): GetSubnetLinkerConvertibleNodesResponse {
  return { resources: [], devices: [] };
}

export const GetSubnetLinkerConvertibleNodesResponse: MessageFns<GetSubnetLinkerConvertibleNodesResponse> = {
  encode(message: GetSubnetLinkerConvertibleNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubnetLinkerConvertibleNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubnetLinkerConvertibleNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubnetLinkerConvertibleNodesResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSubnetLinkerConvertibleNodesResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubnetLinkerConvertibleNodesResponse>, I>>(
    base?: I,
  ): GetSubnetLinkerConvertibleNodesResponse {
    return GetSubnetLinkerConvertibleNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubnetLinkerConvertibleNodesResponse>, I>>(
    object: I,
  ): GetSubnetLinkerConvertibleNodesResponse {
    const message = createBaseGetSubnetLinkerConvertibleNodesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchSubnetLinkerRequest(): PatchSubnetLinkerRequest {
  return { id: "", name: undefined, desc: undefined, advertisedRoutes: [] };
}

export const PatchSubnetLinkerRequest: MessageFns<PatchSubnetLinkerRequest> = {
  encode(message: PatchSubnetLinkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== undefined) {
      writer.uint32(26).string(message.desc);
    }
    for (const v of message.advertisedRoutes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchSubnetLinkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchSubnetLinkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.advertisedRoutes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchSubnetLinkerRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      desc: isSet(object.desc) ? globalThis.String(object.desc) : undefined,
      advertisedRoutes: globalThis.Array.isArray(object?.advertisedRoutes)
        ? object.advertisedRoutes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PatchSubnetLinkerRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.desc !== undefined) {
      obj.desc = message.desc;
    }
    if (message.advertisedRoutes?.length) {
      obj.advertisedRoutes = message.advertisedRoutes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchSubnetLinkerRequest>, I>>(base?: I): PatchSubnetLinkerRequest {
    return PatchSubnetLinkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchSubnetLinkerRequest>, I>>(object: I): PatchSubnetLinkerRequest {
    const message = createBasePatchSubnetLinkerRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.desc = object.desc ?? undefined;
    message.advertisedRoutes = object.advertisedRoutes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSubnetLinkersReponse(): GetSubnetLinkersReponse {
  return { linkers: [] };
}

export const GetSubnetLinkersReponse: MessageFns<GetSubnetLinkersReponse> = {
  encode(message: GetSubnetLinkersReponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkers) {
      Linker.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubnetLinkersReponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubnetLinkersReponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.linkers.push(Linker.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubnetLinkersReponse {
    return {
      linkers: globalThis.Array.isArray(object?.linkers) ? object.linkers.map((e: any) => Linker.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSubnetLinkersReponse): unknown {
    const obj: any = {};
    if (message.linkers?.length) {
      obj.linkers = message.linkers.map((e) => Linker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubnetLinkersReponse>, I>>(base?: I): GetSubnetLinkersReponse {
    return GetSubnetLinkersReponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubnetLinkersReponse>, I>>(object: I): GetSubnetLinkersReponse {
    const message = createBaseGetSubnetLinkersReponse();
    message.linkers = object.linkers?.map((e) => Linker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLinker(): Linker {
  return {
    id: "",
    linkerType: 0,
    nodeId: 0,
    nodeType: 0,
    name: "",
    desc: "",
    email: "",
    domain: "",
    ip: "",
    advertisedRoutes: [],
    host: "",
    os: "",
    nodeKey: "",
    platform: 0,
    createdBy: "",
    createdAt: "",
    status: false,
    lastSeen: "",
  };
}

export const Linker: MessageFns<Linker> = {
  encode(message: Linker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.linkerType !== 0) {
      writer.uint32(16).int32(message.linkerType);
    }
    if (message.nodeId !== 0) {
      writer.uint32(24).uint64(message.nodeId);
    }
    if (message.nodeType !== 0) {
      writer.uint32(32).int32(message.nodeType);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(50).string(message.desc);
    }
    if (message.email !== "") {
      writer.uint32(58).string(message.email);
    }
    if (message.domain !== "") {
      writer.uint32(66).string(message.domain);
    }
    if (message.ip !== "") {
      writer.uint32(74).string(message.ip);
    }
    for (const v of message.advertisedRoutes) {
      writer.uint32(82).string(v!);
    }
    if (message.host !== "") {
      writer.uint32(90).string(message.host);
    }
    if (message.os !== "") {
      writer.uint32(98).string(message.os);
    }
    if (message.nodeKey !== "") {
      writer.uint32(106).string(message.nodeKey);
    }
    if (message.platform !== 0) {
      writer.uint32(112).int32(message.platform);
    }
    if (message.createdBy !== "") {
      writer.uint32(122).string(message.createdBy);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.status !== false) {
      writer.uint32(136).bool(message.status);
    }
    if (message.lastSeen !== "") {
      writer.uint32(146).string(message.lastSeen);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Linker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.linkerType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nodeType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.advertisedRoutes.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.host = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.os = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.nodeKey = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.lastSeen = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Linker {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      linkerType: isSet(object.linkerType) ? linkerTypeFromJSON(object.linkerType) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      nodeType: isSet(object.nodeType) ? nodeTypeFromJSON(object.nodeType) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      advertisedRoutes: globalThis.Array.isArray(object?.advertisedRoutes)
        ? object.advertisedRoutes.map((e: any) => globalThis.String(e))
        : [],
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      nodeKey: isSet(object.nodeKey) ? globalThis.String(object.nodeKey) : "",
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      lastSeen: isSet(object.lastSeen) ? globalThis.String(object.lastSeen) : "",
    };
  },

  toJSON(message: Linker): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.linkerType !== 0) {
      obj.linkerType = linkerTypeToJSON(message.linkerType);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.nodeType !== 0) {
      obj.nodeType = nodeTypeToJSON(message.nodeType);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.advertisedRoutes?.length) {
      obj.advertisedRoutes = message.advertisedRoutes;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.nodeKey !== "") {
      obj.nodeKey = message.nodeKey;
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.lastSeen !== "") {
      obj.lastSeen = message.lastSeen;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Linker>, I>>(base?: I): Linker {
    return Linker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Linker>, I>>(object: I): Linker {
    const message = createBaseLinker();
    message.id = object.id ?? "";
    message.linkerType = object.linkerType ?? 0;
    message.nodeId = object.nodeId ?? 0;
    message.nodeType = object.nodeType ?? 0;
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.email = object.email ?? "";
    message.domain = object.domain ?? "";
    message.ip = object.ip ?? "";
    message.advertisedRoutes = object.advertisedRoutes?.map((e) => e) || [];
    message.host = object.host ?? "";
    message.os = object.os ?? "";
    message.nodeKey = object.nodeKey ?? "";
    message.platform = object.platform ?? 0;
    message.createdBy = object.createdBy ?? "";
    message.createdAt = object.createdAt ?? "";
    message.status = object.status ?? false;
    message.lastSeen = object.lastSeen ?? "";
    return message;
  },
};

function createBaseCreateSubnetLinkerResponse(): CreateSubnetLinkerResponse {
  return { id: "", nodeId: 0, name: "", desc: "", advertisedRoutes: [] };
}

export const CreateSubnetLinkerResponse: MessageFns<CreateSubnetLinkerResponse> = {
  encode(message: CreateSubnetLinkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint64(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(34).string(message.desc);
    }
    for (const v of message.advertisedRoutes) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubnetLinkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubnetLinkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.advertisedRoutes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubnetLinkerResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      advertisedRoutes: globalThis.Array.isArray(object?.advertisedRoutes)
        ? object.advertisedRoutes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateSubnetLinkerResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.advertisedRoutes?.length) {
      obj.advertisedRoutes = message.advertisedRoutes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSubnetLinkerResponse>, I>>(base?: I): CreateSubnetLinkerResponse {
    return CreateSubnetLinkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSubnetLinkerResponse>, I>>(object: I): CreateSubnetLinkerResponse {
    const message = createBaseCreateSubnetLinkerResponse();
    message.id = object.id ?? "";
    message.nodeId = object.nodeId ?? 0;
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.advertisedRoutes = object.advertisedRoutes?.map((e) => e) || [];
    return message;
  },
};

function createBasePatchSubnetLinkerResponse(): PatchSubnetLinkerResponse {
  return { id: "", nodeIds: 0, name: "", desc: "", advertisedRoutes: [] };
}

export const PatchSubnetLinkerResponse: MessageFns<PatchSubnetLinkerResponse> = {
  encode(message: PatchSubnetLinkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nodeIds !== 0) {
      writer.uint32(16).uint64(message.nodeIds);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(34).string(message.desc);
    }
    for (const v of message.advertisedRoutes) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchSubnetLinkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchSubnetLinkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeIds = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.advertisedRoutes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchSubnetLinkerResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nodeIds: isSet(object.nodeIds) ? globalThis.Number(object.nodeIds) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      advertisedRoutes: globalThis.Array.isArray(object?.advertisedRoutes)
        ? object.advertisedRoutes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PatchSubnetLinkerResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nodeIds !== 0) {
      obj.nodeIds = Math.round(message.nodeIds);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.advertisedRoutes?.length) {
      obj.advertisedRoutes = message.advertisedRoutes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchSubnetLinkerResponse>, I>>(base?: I): PatchSubnetLinkerResponse {
    return PatchSubnetLinkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchSubnetLinkerResponse>, I>>(object: I): PatchSubnetLinkerResponse {
    const message = createBasePatchSubnetLinkerResponse();
    message.id = object.id ?? "";
    message.nodeIds = object.nodeIds ?? 0;
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.advertisedRoutes = object.advertisedRoutes?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicy(): Policy {
  return { fleets: [], resources: [], groups: [], users: [], inks: [], devices: [], linkers: [] };
}

export const Policy: MessageFns<Policy> = {
  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fleets) {
      Fleet.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.users) {
      User.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.inks) {
      Ink.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.linkers) {
      Linker.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fleets.push(Fleet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inks.push(Ink.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.linkers.push(Linker.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      fleets: globalThis.Array.isArray(object?.fleets) ? object.fleets.map((e: any) => Fleet.fromJSON(e)) : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [],
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      inks: globalThis.Array.isArray(object?.inks) ? object.inks.map((e: any) => Ink.fromJSON(e)) : [],
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      linkers: globalThis.Array.isArray(object?.linkers) ? object.linkers.map((e: any) => Linker.fromJSON(e)) : [],
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.fleets?.length) {
      obj.fleets = message.fleets.map((e) => Fleet.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.inks?.length) {
      obj.inks = message.inks.map((e) => Ink.toJSON(e));
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.linkers?.length) {
      obj.linkers = message.linkers.map((e) => Linker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policy>, I>>(base?: I): Policy {
    return Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policy>, I>>(object: I): Policy {
    const message = createBasePolicy();
    message.fleets = object.fleets?.map((e) => Fleet.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.inks = object.inks?.map((e) => Ink.fromPartial(e)) || [];
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.linkers = object.linkers?.map((e) => Linker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFleet(): Fleet {
  return {
    id: "",
    name: "",
    desc: "",
    resources: [],
    ipProto: [],
    ports: "",
    updatedAt: "",
    platform: 0,
    createdBy: "",
  };
}

export const Fleet: MessageFns<Fleet> = {
  encode(message: Fleet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.ipProto) {
      writer.int32(v);
    }
    writer.join();
    if (message.ports !== "") {
      writer.uint32(50).string(message.ports);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    if (message.platform !== 0) {
      writer.uint32(64).int32(message.platform);
    }
    if (message.createdBy !== "") {
      writer.uint32(74).string(message.createdBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fleet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFleet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag === 40) {
            message.ipProto.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ipProto.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ports = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fleet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      ipProto: globalThis.Array.isArray(object?.ipProto) ? object.ipProto.map((e: any) => iPProtoFromJSON(e)) : [],
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
    };
  },

  toJSON(message: Fleet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.ipProto?.length) {
      obj.ipProto = message.ipProto.map((e) => iPProtoToJSON(e));
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fleet>, I>>(base?: I): Fleet {
    return Fleet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fleet>, I>>(object: I): Fleet {
    const message = createBaseFleet();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.ipProto = object.ipProto?.map((e) => e) || [];
    message.ports = object.ports ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.platform = object.platform ?? 0;
    message.createdBy = object.createdBy ?? "";
    return message;
  },
};

function createBaseResource(): Resource {
  return {
    id: "",
    nodeId: 0,
    name: "",
    email: "",
    ip: "",
    ports: "",
    ipProto: [],
    os: "",
    platform: 0,
    status: false,
    createdBy: "",
    lastSeen: "",
    isLinker: false,
    linker: undefined,
    fleets: [],
  };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint64(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.ip !== "") {
      writer.uint32(42).string(message.ip);
    }
    if (message.ports !== "") {
      writer.uint32(50).string(message.ports);
    }
    writer.uint32(58).fork();
    for (const v of message.ipProto) {
      writer.int32(v);
    }
    writer.join();
    if (message.os !== "") {
      writer.uint32(66).string(message.os);
    }
    if (message.platform !== 0) {
      writer.uint32(72).int32(message.platform);
    }
    if (message.status !== false) {
      writer.uint32(80).bool(message.status);
    }
    if (message.createdBy !== "") {
      writer.uint32(90).string(message.createdBy);
    }
    if (message.lastSeen !== "") {
      writer.uint32(98).string(message.lastSeen);
    }
    if (message.isLinker !== false) {
      writer.uint32(104).bool(message.isLinker);
    }
    if (message.linker !== undefined) {
      Linker.encode(message.linker, writer.uint32(114).fork()).join();
    }
    for (const v of message.fleets) {
      Fleet.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ports = reader.string();
          continue;
        case 7:
          if (tag === 56) {
            message.ipProto.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ipProto.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.os = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.lastSeen = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isLinker = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.linker = Linker.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.fleets.push(Fleet.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
      ipProto: globalThis.Array.isArray(object?.ipProto) ? object.ipProto.map((e: any) => iPProtoFromJSON(e)) : [],
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      lastSeen: isSet(object.lastSeen) ? globalThis.String(object.lastSeen) : "",
      isLinker: isSet(object.isLinker) ? globalThis.Boolean(object.isLinker) : false,
      linker: isSet(object.linker) ? Linker.fromJSON(object.linker) : undefined,
      fleets: globalThis.Array.isArray(object?.fleets) ? object.fleets.map((e: any) => Fleet.fromJSON(e)) : [],
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    if (message.ipProto?.length) {
      obj.ipProto = message.ipProto.map((e) => iPProtoToJSON(e));
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.lastSeen !== "") {
      obj.lastSeen = message.lastSeen;
    }
    if (message.isLinker !== false) {
      obj.isLinker = message.isLinker;
    }
    if (message.linker !== undefined) {
      obj.linker = Linker.toJSON(message.linker);
    }
    if (message.fleets?.length) {
      obj.fleets = message.fleets.map((e) => Fleet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.id = object.id ?? "";
    message.nodeId = object.nodeId ?? 0;
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.ip = object.ip ?? "";
    message.ports = object.ports ?? "";
    message.ipProto = object.ipProto?.map((e) => e) || [];
    message.os = object.os ?? "";
    message.platform = object.platform ?? 0;
    message.status = object.status ?? false;
    message.createdBy = object.createdBy ?? "";
    message.lastSeen = object.lastSeen ?? "";
    message.isLinker = object.isLinker ?? false;
    message.linker = (object.linker !== undefined && object.linker !== null)
      ? Linker.fromPartial(object.linker)
      : undefined;
    message.fleets = object.fleets?.map((e) => Fleet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroup(): Group {
  return { id: "", name: "", desc: "", users: [], updatedAt: "" };
}

export const Group: MessageFns<Group> = {
  encode(message: Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    for (const v of message.users) {
      User.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Group>, I>>(base?: I): Group {
    return Group.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Group>, I>>(object: I): Group {
    const message = createBaseGroup();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    nodeId: 0,
    name: "",
    picture: "",
    email: "",
    role: "",
    joined: "",
    lastSeen: "",
    status: false,
    groups: [],
    devices: [],
    resources: [],
    fleets: [],
    inks: [],
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.picture !== "") {
      writer.uint32(26).string(message.picture);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(42).string(message.role);
    }
    if (message.joined !== "") {
      writer.uint32(50).string(message.joined);
    }
    if (message.lastSeen !== "") {
      writer.uint32(58).string(message.lastSeen);
    }
    if (message.status !== false) {
      writer.uint32(64).bool(message.status);
    }
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.fleets) {
      Fleet.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.inks) {
      Ink.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.picture = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.role = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.joined = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastSeen = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.fleets.push(Fleet.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.inks.push(Ink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      picture: isSet(object.picture) ? globalThis.String(object.picture) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      joined: isSet(object.joined) ? globalThis.String(object.joined) : "",
      lastSeen: isSet(object.lastSeen) ? globalThis.String(object.lastSeen) : "",
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [],
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      fleets: globalThis.Array.isArray(object?.fleets) ? object.fleets.map((e: any) => Fleet.fromJSON(e)) : [],
      inks: globalThis.Array.isArray(object?.inks) ? object.inks.map((e: any) => Ink.fromJSON(e)) : [],
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.picture !== "") {
      obj.picture = message.picture;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.joined !== "") {
      obj.joined = message.joined;
    }
    if (message.lastSeen !== "") {
      obj.lastSeen = message.lastSeen;
    }
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.fleets?.length) {
      obj.fleets = message.fleets.map((e) => Fleet.toJSON(e));
    }
    if (message.inks?.length) {
      obj.inks = message.inks.map((e) => Ink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.nodeId = object.nodeId ?? 0;
    message.name = object.name ?? "";
    message.picture = object.picture ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    message.joined = object.joined ?? "";
    message.lastSeen = object.lastSeen ?? "";
    message.status = object.status ?? false;
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.fleets = object.fleets?.map((e) => Fleet.fromPartial(e)) || [];
    message.inks = object.inks?.map((e) => Ink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDevice(): Device {
  return {
    nodeId: 0,
    name: "",
    email: "",
    ip: "",
    ports: "",
    os: "",
    status: false,
    lastSeen: "",
    createdBy: "",
    version: "",
    nodeKey: "",
    createdAt: "",
    keyExpiry: "",
    isLinker: false,
    linker: undefined,
    inks: [],
  };
}

export const Device: MessageFns<Device> = {
  encode(message: Device, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.ip !== "") {
      writer.uint32(34).string(message.ip);
    }
    if (message.ports !== "") {
      writer.uint32(42).string(message.ports);
    }
    if (message.os !== "") {
      writer.uint32(50).string(message.os);
    }
    if (message.status !== false) {
      writer.uint32(56).bool(message.status);
    }
    if (message.lastSeen !== "") {
      writer.uint32(66).string(message.lastSeen);
    }
    if (message.createdBy !== "") {
      writer.uint32(74).string(message.createdBy);
    }
    if (message.version !== "") {
      writer.uint32(82).string(message.version);
    }
    if (message.nodeKey !== "") {
      writer.uint32(90).string(message.nodeKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.keyExpiry !== "") {
      writer.uint32(106).string(message.keyExpiry);
    }
    if (message.isLinker !== false) {
      writer.uint32(112).bool(message.isLinker);
    }
    if (message.linker !== undefined) {
      Linker.encode(message.linker, writer.uint32(122).fork()).join();
    }
    for (const v of message.inks) {
      Ink.encode(v!, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ports = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.os = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastSeen = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.version = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.nodeKey = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.keyExpiry = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isLinker = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.linker = Linker.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.inks.push(Ink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      ports: isSet(object.ports) ? globalThis.String(object.ports) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      lastSeen: isSet(object.lastSeen) ? globalThis.String(object.lastSeen) : "",
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      nodeKey: isSet(object.nodeKey) ? globalThis.String(object.nodeKey) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      keyExpiry: isSet(object.keyExpiry) ? globalThis.String(object.keyExpiry) : "",
      isLinker: isSet(object.isLinker) ? globalThis.Boolean(object.isLinker) : false,
      linker: isSet(object.linker) ? Linker.fromJSON(object.linker) : undefined,
      inks: globalThis.Array.isArray(object?.inks) ? object.inks.map((e: any) => Ink.fromJSON(e)) : [],
    };
  },

  toJSON(message: Device): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.ports !== "") {
      obj.ports = message.ports;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.lastSeen !== "") {
      obj.lastSeen = message.lastSeen;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.nodeKey !== "") {
      obj.nodeKey = message.nodeKey;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.keyExpiry !== "") {
      obj.keyExpiry = message.keyExpiry;
    }
    if (message.isLinker !== false) {
      obj.isLinker = message.isLinker;
    }
    if (message.linker !== undefined) {
      obj.linker = Linker.toJSON(message.linker);
    }
    if (message.inks?.length) {
      obj.inks = message.inks.map((e) => Ink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Device>, I>>(base?: I): Device {
    return Device.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Device>, I>>(object: I): Device {
    const message = createBaseDevice();
    message.nodeId = object.nodeId ?? 0;
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.ip = object.ip ?? "";
    message.ports = object.ports ?? "";
    message.os = object.os ?? "";
    message.status = object.status ?? false;
    message.lastSeen = object.lastSeen ?? "";
    message.createdBy = object.createdBy ?? "";
    message.version = object.version ?? "";
    message.nodeKey = object.nodeKey ?? "";
    message.createdAt = object.createdAt ?? "";
    message.keyExpiry = object.keyExpiry ?? "";
    message.isLinker = object.isLinker ?? false;
    message.linker = (object.linker !== undefined && object.linker !== null)
      ? Linker.fromPartial(object.linker)
      : undefined;
    message.inks = object.inks?.map((e) => Ink.fromPartial(e)) || [];
    return message;
  },
};

export interface AdminService {
  GetMe(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetMeResponse>;
  GetUser(request: DeepPartial<GetUserRequest>, metadata?: grpc.Metadata): Promise<User>;
  GetUsers(request: DeepPartial<GetUsersRequest>, metadata?: grpc.Metadata): Promise<Users>;
  PatchUser(request: DeepPartial<PatchUserRequest>, metadata?: grpc.Metadata): Promise<User>;
  /** acls */
  CreateAcl(request: DeepPartial<CreateAclRequest>, metadata?: grpc.Metadata): Promise<AclResponse>;
  GetAcl(request: DeepPartial<GetAclRequest>, metadata?: grpc.Metadata): Promise<AclResponse>;
  GetAcls(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetAclsResponse>;
  GetAclsJson(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetAclsJsonResponse>;
  PatchAcl(request: DeepPartial<PatchAclRequest>, metadata?: grpc.Metadata): Promise<AclResponse>;
  /** groups */
  CreateGroup(request: DeepPartial<CreateGroupRequest>, metadata?: grpc.Metadata): Promise<Group>;
  GetGroup(request: DeepPartial<GetGroupRequest>, metadata?: grpc.Metadata): Promise<Group>;
  GetGroups(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Groups>;
  PatchGroup(request: DeepPartial<PatchGroupRequest>, metadata?: grpc.Metadata): Promise<Group>;
  /** devices */
  GetDevice(request: DeepPartial<GetDeviceRequest>, metadata?: grpc.Metadata): Promise<Device>;
  GetDevices(request: DeepPartial<GetDevicesRequest>, metadata?: grpc.Metadata): Promise<Devices>;
  /** resources */
  GetResource(request: DeepPartial<GetResourceRequest>, metadata?: grpc.Metadata): Promise<Resource>;
  GetResources(request: DeepPartial<GetResourcesRequest>, metadata?: grpc.Metadata): Promise<Resources>;
  /** compose keys */
  GenerateComposeKey(
    request: DeepPartial<GenerateComposeKeyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenerateComposeKeyResponse>;
  GetComposeKeys(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetComposeKeysResponse>;
  GetComposeNodeStatus(
    request: DeepPartial<GetComposeNodeStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetComposeNodeStatusResponse>;
  /** fleets */
  CreateFleet(request: DeepPartial<CreateFleetRequest>, metadata?: grpc.Metadata): Promise<Fleet>;
  GetFleet(request: DeepPartial<GetFleetRequest>, metadata?: grpc.Metadata): Promise<Fleet>;
  GetFleets(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Fleets>;
  PatchFleet(request: DeepPartial<PatchFleetRequest>, metadata?: grpc.Metadata): Promise<Fleet>;
  /** inks */
  CreateInk(request: DeepPartial<CreateInkRequest>, metadata?: grpc.Metadata): Promise<Ink>;
  GetInk(request: DeepPartial<GetInkRequest>, metadata?: grpc.Metadata): Promise<Ink>;
  GetInks(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Inks>;
  PatchInk(request: DeepPartial<PatchInkRequest>, metadata?: grpc.Metadata): Promise<Ink>;
  /** overview */
  GetOverview(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Overview>;
  /** invite */
  CreateInviteUser(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<InviteUserResponse>;
  /** linker */
  GetSubnetLinkers(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetSubnetLinkersReponse>;
  CreateSubnetLinker(
    request: DeepPartial<CreateSubnetLinkerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<CreateSubnetLinkerResponse>;
  GetSubnetLinkerConvertibleNodes(
    request: DeepPartial<Empty>,
    metadata?: grpc.Metadata,
  ): Promise<GetSubnetLinkerConvertibleNodesResponse>;
  PatchSubnetLinker(
    request: DeepPartial<PatchSubnetLinkerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PatchSubnetLinkerResponse>;
}

export class AdminServiceClientImpl implements AdminService {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetMe = this.GetMe.bind(this);
    this.GetUser = this.GetUser.bind(this);
    this.GetUsers = this.GetUsers.bind(this);
    this.PatchUser = this.PatchUser.bind(this);
    this.CreateAcl = this.CreateAcl.bind(this);
    this.GetAcl = this.GetAcl.bind(this);
    this.GetAcls = this.GetAcls.bind(this);
    this.GetAclsJson = this.GetAclsJson.bind(this);
    this.PatchAcl = this.PatchAcl.bind(this);
    this.CreateGroup = this.CreateGroup.bind(this);
    this.GetGroup = this.GetGroup.bind(this);
    this.GetGroups = this.GetGroups.bind(this);
    this.PatchGroup = this.PatchGroup.bind(this);
    this.GetDevice = this.GetDevice.bind(this);
    this.GetDevices = this.GetDevices.bind(this);
    this.GetResource = this.GetResource.bind(this);
    this.GetResources = this.GetResources.bind(this);
    this.GenerateComposeKey = this.GenerateComposeKey.bind(this);
    this.GetComposeKeys = this.GetComposeKeys.bind(this);
    this.GetComposeNodeStatus = this.GetComposeNodeStatus.bind(this);
    this.CreateFleet = this.CreateFleet.bind(this);
    this.GetFleet = this.GetFleet.bind(this);
    this.GetFleets = this.GetFleets.bind(this);
    this.PatchFleet = this.PatchFleet.bind(this);
    this.CreateInk = this.CreateInk.bind(this);
    this.GetInk = this.GetInk.bind(this);
    this.GetInks = this.GetInks.bind(this);
    this.PatchInk = this.PatchInk.bind(this);
    this.GetOverview = this.GetOverview.bind(this);
    this.CreateInviteUser = this.CreateInviteUser.bind(this);
    this.GetSubnetLinkers = this.GetSubnetLinkers.bind(this);
    this.CreateSubnetLinker = this.CreateSubnetLinker.bind(this);
    this.GetSubnetLinkerConvertibleNodes = this.GetSubnetLinkerConvertibleNodes.bind(this);
    this.PatchSubnetLinker = this.PatchSubnetLinker.bind(this);
  }

  GetMe(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetMeResponse> {
    return this.rpc.unary(AdminServiceGetMeDesc, Empty.fromPartial(request), metadata);
  }

  GetUser(request: DeepPartial<GetUserRequest>, metadata?: grpc.Metadata): Promise<User> {
    return this.rpc.unary(AdminServiceGetUserDesc, GetUserRequest.fromPartial(request), metadata);
  }

  GetUsers(request: DeepPartial<GetUsersRequest>, metadata?: grpc.Metadata): Promise<Users> {
    return this.rpc.unary(AdminServiceGetUsersDesc, GetUsersRequest.fromPartial(request), metadata);
  }

  PatchUser(request: DeepPartial<PatchUserRequest>, metadata?: grpc.Metadata): Promise<User> {
    return this.rpc.unary(AdminServicePatchUserDesc, PatchUserRequest.fromPartial(request), metadata);
  }

  CreateAcl(request: DeepPartial<CreateAclRequest>, metadata?: grpc.Metadata): Promise<AclResponse> {
    return this.rpc.unary(AdminServiceCreateAclDesc, CreateAclRequest.fromPartial(request), metadata);
  }

  GetAcl(request: DeepPartial<GetAclRequest>, metadata?: grpc.Metadata): Promise<AclResponse> {
    return this.rpc.unary(AdminServiceGetAclDesc, GetAclRequest.fromPartial(request), metadata);
  }

  GetAcls(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetAclsResponse> {
    return this.rpc.unary(AdminServiceGetAclsDesc, Empty.fromPartial(request), metadata);
  }

  GetAclsJson(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetAclsJsonResponse> {
    return this.rpc.unary(AdminServiceGetAclsJsonDesc, Empty.fromPartial(request), metadata);
  }

  PatchAcl(request: DeepPartial<PatchAclRequest>, metadata?: grpc.Metadata): Promise<AclResponse> {
    return this.rpc.unary(AdminServicePatchAclDesc, PatchAclRequest.fromPartial(request), metadata);
  }

  CreateGroup(request: DeepPartial<CreateGroupRequest>, metadata?: grpc.Metadata): Promise<Group> {
    return this.rpc.unary(AdminServiceCreateGroupDesc, CreateGroupRequest.fromPartial(request), metadata);
  }

  GetGroup(request: DeepPartial<GetGroupRequest>, metadata?: grpc.Metadata): Promise<Group> {
    return this.rpc.unary(AdminServiceGetGroupDesc, GetGroupRequest.fromPartial(request), metadata);
  }

  GetGroups(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Groups> {
    return this.rpc.unary(AdminServiceGetGroupsDesc, Empty.fromPartial(request), metadata);
  }

  PatchGroup(request: DeepPartial<PatchGroupRequest>, metadata?: grpc.Metadata): Promise<Group> {
    return this.rpc.unary(AdminServicePatchGroupDesc, PatchGroupRequest.fromPartial(request), metadata);
  }

  GetDevice(request: DeepPartial<GetDeviceRequest>, metadata?: grpc.Metadata): Promise<Device> {
    return this.rpc.unary(AdminServiceGetDeviceDesc, GetDeviceRequest.fromPartial(request), metadata);
  }

  GetDevices(request: DeepPartial<GetDevicesRequest>, metadata?: grpc.Metadata): Promise<Devices> {
    return this.rpc.unary(AdminServiceGetDevicesDesc, GetDevicesRequest.fromPartial(request), metadata);
  }

  GetResource(request: DeepPartial<GetResourceRequest>, metadata?: grpc.Metadata): Promise<Resource> {
    return this.rpc.unary(AdminServiceGetResourceDesc, GetResourceRequest.fromPartial(request), metadata);
  }

  GetResources(request: DeepPartial<GetResourcesRequest>, metadata?: grpc.Metadata): Promise<Resources> {
    return this.rpc.unary(AdminServiceGetResourcesDesc, GetResourcesRequest.fromPartial(request), metadata);
  }

  GenerateComposeKey(
    request: DeepPartial<GenerateComposeKeyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenerateComposeKeyResponse> {
    return this.rpc.unary(AdminServiceGenerateComposeKeyDesc, GenerateComposeKeyRequest.fromPartial(request), metadata);
  }

  GetComposeKeys(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetComposeKeysResponse> {
    return this.rpc.unary(AdminServiceGetComposeKeysDesc, Empty.fromPartial(request), metadata);
  }

  GetComposeNodeStatus(
    request: DeepPartial<GetComposeNodeStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetComposeNodeStatusResponse> {
    return this.rpc.unary(
      AdminServiceGetComposeNodeStatusDesc,
      GetComposeNodeStatusRequest.fromPartial(request),
      metadata,
    );
  }

  CreateFleet(request: DeepPartial<CreateFleetRequest>, metadata?: grpc.Metadata): Promise<Fleet> {
    return this.rpc.unary(AdminServiceCreateFleetDesc, CreateFleetRequest.fromPartial(request), metadata);
  }

  GetFleet(request: DeepPartial<GetFleetRequest>, metadata?: grpc.Metadata): Promise<Fleet> {
    return this.rpc.unary(AdminServiceGetFleetDesc, GetFleetRequest.fromPartial(request), metadata);
  }

  GetFleets(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Fleets> {
    return this.rpc.unary(AdminServiceGetFleetsDesc, Empty.fromPartial(request), metadata);
  }

  PatchFleet(request: DeepPartial<PatchFleetRequest>, metadata?: grpc.Metadata): Promise<Fleet> {
    return this.rpc.unary(AdminServicePatchFleetDesc, PatchFleetRequest.fromPartial(request), metadata);
  }

  CreateInk(request: DeepPartial<CreateInkRequest>, metadata?: grpc.Metadata): Promise<Ink> {
    return this.rpc.unary(AdminServiceCreateInkDesc, CreateInkRequest.fromPartial(request), metadata);
  }

  GetInk(request: DeepPartial<GetInkRequest>, metadata?: grpc.Metadata): Promise<Ink> {
    return this.rpc.unary(AdminServiceGetInkDesc, GetInkRequest.fromPartial(request), metadata);
  }

  GetInks(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Inks> {
    return this.rpc.unary(AdminServiceGetInksDesc, Empty.fromPartial(request), metadata);
  }

  PatchInk(request: DeepPartial<PatchInkRequest>, metadata?: grpc.Metadata): Promise<Ink> {
    return this.rpc.unary(AdminServicePatchInkDesc, PatchInkRequest.fromPartial(request), metadata);
  }

  GetOverview(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<Overview> {
    return this.rpc.unary(AdminServiceGetOverviewDesc, Empty.fromPartial(request), metadata);
  }

  CreateInviteUser(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<InviteUserResponse> {
    return this.rpc.unary(AdminServiceCreateInviteUserDesc, Empty.fromPartial(request), metadata);
  }

  GetSubnetLinkers(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<GetSubnetLinkersReponse> {
    return this.rpc.unary(AdminServiceGetSubnetLinkersDesc, Empty.fromPartial(request), metadata);
  }

  CreateSubnetLinker(
    request: DeepPartial<CreateSubnetLinkerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<CreateSubnetLinkerResponse> {
    return this.rpc.unary(AdminServiceCreateSubnetLinkerDesc, CreateSubnetLinkerRequest.fromPartial(request), metadata);
  }

  GetSubnetLinkerConvertibleNodes(
    request: DeepPartial<Empty>,
    metadata?: grpc.Metadata,
  ): Promise<GetSubnetLinkerConvertibleNodesResponse> {
    return this.rpc.unary(AdminServiceGetSubnetLinkerConvertibleNodesDesc, Empty.fromPartial(request), metadata);
  }

  PatchSubnetLinker(
    request: DeepPartial<PatchSubnetLinkerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PatchSubnetLinkerResponse> {
    return this.rpc.unary(AdminServicePatchSubnetLinkerDesc, PatchSubnetLinkerRequest.fromPartial(request), metadata);
  }
}

export const AdminServiceDesc = { serviceName: "protos.AdminService" };

export const AdminServiceGetMeDesc: UnaryMethodDefinitionish = {
  methodName: "GetMe",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetMeResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetUserDesc: UnaryMethodDefinitionish = {
  methodName: "GetUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = User.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetUsersDesc: UnaryMethodDefinitionish = {
  methodName: "GetUsers",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUsersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Users.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePatchUserDesc: UnaryMethodDefinitionish = {
  methodName: "PatchUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PatchUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = User.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateAclDesc: UnaryMethodDefinitionish = {
  methodName: "CreateAcl",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateAclRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AclResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetAclDesc: UnaryMethodDefinitionish = {
  methodName: "GetAcl",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetAclRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AclResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetAclsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAcls",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetAclsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetAclsJsonDesc: UnaryMethodDefinitionish = {
  methodName: "GetAclsJson",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetAclsJsonResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePatchAclDesc: UnaryMethodDefinitionish = {
  methodName: "PatchAcl",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PatchAclRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AclResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateGroupDesc: UnaryMethodDefinitionish = {
  methodName: "CreateGroup",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateGroupRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Group.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetGroupDesc: UnaryMethodDefinitionish = {
  methodName: "GetGroup",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetGroupRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Group.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetGroupsDesc: UnaryMethodDefinitionish = {
  methodName: "GetGroups",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Groups.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePatchGroupDesc: UnaryMethodDefinitionish = {
  methodName: "PatchGroup",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PatchGroupRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Group.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetDeviceDesc: UnaryMethodDefinitionish = {
  methodName: "GetDevice",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDeviceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Device.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetDevicesDesc: UnaryMethodDefinitionish = {
  methodName: "GetDevices",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDevicesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Devices.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetResourceDesc: UnaryMethodDefinitionish = {
  methodName: "GetResource",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetResourceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Resource.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetResourcesDesc: UnaryMethodDefinitionish = {
  methodName: "GetResources",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetResourcesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Resources.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGenerateComposeKeyDesc: UnaryMethodDefinitionish = {
  methodName: "GenerateComposeKey",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenerateComposeKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenerateComposeKeyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetComposeKeysDesc: UnaryMethodDefinitionish = {
  methodName: "GetComposeKeys",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetComposeKeysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetComposeNodeStatusDesc: UnaryMethodDefinitionish = {
  methodName: "GetComposeNodeStatus",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetComposeNodeStatusRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetComposeNodeStatusResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateFleetDesc: UnaryMethodDefinitionish = {
  methodName: "CreateFleet",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateFleetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Fleet.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetFleetDesc: UnaryMethodDefinitionish = {
  methodName: "GetFleet",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetFleetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Fleet.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetFleetsDesc: UnaryMethodDefinitionish = {
  methodName: "GetFleets",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Fleets.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePatchFleetDesc: UnaryMethodDefinitionish = {
  methodName: "PatchFleet",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PatchFleetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Fleet.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateInkDesc: UnaryMethodDefinitionish = {
  methodName: "CreateInk",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateInkRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Ink.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetInkDesc: UnaryMethodDefinitionish = {
  methodName: "GetInk",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetInkRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Ink.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetInksDesc: UnaryMethodDefinitionish = {
  methodName: "GetInks",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Inks.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePatchInkDesc: UnaryMethodDefinitionish = {
  methodName: "PatchInk",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PatchInkRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Ink.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetOverviewDesc: UnaryMethodDefinitionish = {
  methodName: "GetOverview",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Overview.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateInviteUserDesc: UnaryMethodDefinitionish = {
  methodName: "CreateInviteUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = InviteUserResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetSubnetLinkersDesc: UnaryMethodDefinitionish = {
  methodName: "GetSubnetLinkers",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSubnetLinkersReponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateSubnetLinkerDesc: UnaryMethodDefinitionish = {
  methodName: "CreateSubnetLinker",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateSubnetLinkerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CreateSubnetLinkerResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetSubnetLinkerConvertibleNodesDesc: UnaryMethodDefinitionish = {
  methodName: "GetSubnetLinkerConvertibleNodes",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSubnetLinkerConvertibleNodesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePatchSubnetLinkerDesc: UnaryMethodDefinitionish = {
  methodName: "PatchSubnetLinker",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PatchSubnetLinkerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PatchSubnetLinkerResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
